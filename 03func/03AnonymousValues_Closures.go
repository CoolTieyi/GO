package main

import (
	"fmt"
	"strings"
)

func main() {
	//anonymous values & closure
	/*
		拥有函数名的函数只能在包级语法块中被声明
		但通过函数字面量（function literal）我们可绕过这一限制 在任何表达式中表示一个函数值
		[就是在函数返回值的位置直接写函数(字面值) 即 函数可以像普通变量一样被传递或使用]
		函数字面量的语法和函数声明相似 区别在于func关键字后没有函数名
		函数值字面量(function Literal)是一种表达式 它(表达式)的值被称为匿名函数(anonymous function)
	*/
	/*
		是不是因为GO是函数式编程 在主函数里面不能定义其他有名有姓的函数了 所以用一个匿名函数 现用现写 用完拉倒 可以跟变量和参数一样
		那其实函数是什么呢 函数不也是一段命令吗 所以就算不用匿名函数也可以在主程序中完成任务
		但是用了匿名函数之后 设置的变量有生命周期可以被适当销毁 并且多行代码写入代码块中 又简洁了程序有方便了程序员
	*/

	//e.g.1
	fmt.Println( //strings.Map(a1 func(),a2 string) 这个函数对每个a2字符串调用a1函数
		strings.Map(func(r rune) rune { return r + 1 }, "aaaaa")) // 函数作为其他函数的参数 在其他函数内调用 称为回调
	//e.g.2 squares() 见↓
	f := squares()
	fmt.Println(f()) //1
	fmt.Println(f()) //4
	fmt.Println(f()) //9	==》//变量的生命周期不由它的作用域决定:squqres 返回后 变量x仍然隐式的存在于f中  ？？？？？？？？
	//为什么每次调用都是x的值都变呢
	/*
		闭包Closure是包含自由变量的代码块 这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义	【独立的环境】
		要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及他们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）

		闭包的价值在于可以作为函数对象和匿名函数 对于类型系统而言，这意味着不仅要表示数据还要表示代码
		支持闭包的多数语言都将函数作为第一级对象（如GO），就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回
		Golang中的闭包会同样引用到函数外的变量，闭包的实现确保只要闭包还被使用 那么闭包引用的变量会一直存在 从形式上看 匿名函数都是闭包

		其实我们可以将闭包函数看成一个类 (C++)，一个闭包函数调用就是实例化一个对象，
		闭包的自由变量就是类的成员变量，闭包函数的参数就是类的函数对象的参数。
		在该例子中，next 可以看作是实例化的一个对象，next () 可以看做是对象函数调用的返回值。
		这让我们想起了一句名言：对象是附有行为的数据，而闭包是附有数据的行为
	*/

}

//function Literal允许我们在使用函数时再定义它
//通过这种方式定义的函数可以访问完整的词法环境（lexical environment） 意味着在函数中定义的内部函数可以引用该函数的变量
func squares() func() int { //squares返回另一个 func() int 的函数
	//由匿名函数和自由变量组成的代码块其实就是闭包 在闭包中 只有匿名函数才能访问自由变量x
	var x int           //自由变量
	return func() int { //squares()函数返回的匿名函数为自由变量提供了计算环境
		x++
		return x * x
	}
	/*
		按照命令式语言的规则 squares 函数只是返回了匿名函数的地址 但在执行匿名函数时将会由于在其作用域内找不到x变量而出错
		而在函数式语言中 当内嵌函数体内引用到体外的变量时 将会把定义时涉及到的引用环境和函数体打包成一个整体（闭包）返回 闭包的使用和正常的函数调用没有区别
		引用环境： 在程序执行中的某个点 所有处于活跃状态的约束 所组成的集合，其中约束指的是一个变量的名字和器所代表的对象之间的联系
		闭包=匿名函数+引用环境
	*/
}
